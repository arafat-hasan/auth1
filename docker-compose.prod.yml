# Production override for docker-compose.yml
# Usage: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up

services:
  postgres:
    # Use specific version for production stability
    image: postgres:15.4-alpine
    environment:
      POSTGRES_DB: ${DATABASE_NAME:-auth1_prod}
      POSTGRES_USER: ${DATABASE_USER:-auth1_prod}
      POSTGRES_PASSWORD: ${DATABASE_PASSWORD:?DATABASE_PASSWORD is required}
    ports:
      - "${DATABASE_PORT:-5432}:5432"
    volumes:
      - postgres_data_prod:/var/lib/postgresql/data
    # More aggressive health checks for production
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DATABASE_USER:-auth1_prod}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    restart: unless-stopped
    # Resource limits for production
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M

  redis:
    # Use specific version for production stability
    image: redis:7.2-alpine
    ports:
      - "${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 20s
    restart: unless-stopped
    # Redis persistence for production
    command: redis-server --appendonly yes --appendfsync everysec
    volumes:
      - redis_data_prod:/data
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.25'
        reservations:
          memory: 128M

  migrations:
    environment:
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_USER: ${DATABASE_USER:-auth1_prod}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD:?DATABASE_PASSWORD is required}
      DATABASE_NAME: ${DATABASE_NAME:-auth1_prod}
      DATABASE_SSL_MODE: ${DATABASE_SSL_MODE:-require}
      APP_ENVIRONMENT: production
    # Remove config volume mount for production (use env vars)
    volumes: []
    # Production migration command (no seeding)
    command: ["sh", "-c", "set -e && echo 'Starting production migrations...' && ./migrate init && ./migrate up && echo 'Production migrations completed successfully'"]

  auth-service:
    ports:
      - "${HTTP_PORT:-8080}:8080"
    environment:
      DATABASE_HOST: postgres
      DATABASE_PORT: 5432
      DATABASE_USER: ${DATABASE_USER:-auth1_prod}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD:?DATABASE_PASSWORD is required}
      DATABASE_NAME: ${DATABASE_NAME:-auth1_prod}
      DATABASE_SSL_MODE: ${DATABASE_SSL_MODE:-require}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      APP_ENVIRONMENT: production
      APP_LOG_LEVEL: ${LOG_LEVEL:-info}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET is required}
    # Remove config volume mount for production (use env vars)
    volumes:
      - ./assets:/root/assets:ro
    restart: unless-stopped
    # Health check for production monitoring
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M

volumes:
  postgres_data_prod:
  redis_data_prod: